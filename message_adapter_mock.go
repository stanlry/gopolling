// Code generated by MockGen. DO NOT EDIT.
// Source: message_adapter.go

// Package gopolling is a generated GoMock package.
package gopolling

import (
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockSubscription is a mock of Subscription interface
type MockSubscription struct {
	ctrl     *gomock.Controller
	recorder *MockSubscriptionMockRecorder
}

// MockSubscriptionMockRecorder is the mock recorder for MockSubscription
type MockSubscriptionMockRecorder struct {
	mock *MockSubscription
}

// NewMockSubscription creates a new mock instance
func NewMockSubscription(ctrl *gomock.Controller) *MockSubscription {
	mock := &MockSubscription{ctrl: ctrl}
	mock.recorder = &MockSubscriptionMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockSubscription) EXPECT() *MockSubscriptionMockRecorder {
	return m.recorder
}

// Receive mocks base method
func (m *MockSubscription) Receive() <-chan Message {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Receive")
	ret0, _ := ret[0].(<-chan Message)
	return ret0
}

// Receive indicates an expected call of Receive
func (mr *MockSubscriptionMockRecorder) Receive() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Receive", reflect.TypeOf((*MockSubscription)(nil).Receive))
}

// Unsubscribe mocks base method
func (m *MockSubscription) Unsubscribe() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unsubscribe")
	ret0, _ := ret[0].(error)
	return ret0
}

// Unsubscribe indicates an expected call of Unsubscribe
func (mr *MockSubscriptionMockRecorder) Unsubscribe() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unsubscribe", reflect.TypeOf((*MockSubscription)(nil).Unsubscribe))
}

// MockMessageBus is a mock of MessageBus interface
type MockMessageBus struct {
	ctrl     *gomock.Controller
	recorder *MockMessageBusMockRecorder
}

// MockMessageBusMockRecorder is the mock recorder for MockMessageBus
type MockMessageBusMockRecorder struct {
	mock *MockMessageBus
}

// NewMockMessageBus creates a new mock instance
func NewMockMessageBus(ctrl *gomock.Controller) *MockMessageBus {
	mock := &MockMessageBus{ctrl: ctrl}
	mock.recorder = &MockMessageBusMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMessageBus) EXPECT() *MockMessageBusMockRecorder {
	return m.recorder
}

// Publish mocks base method
func (m *MockMessageBus) Publish(arg0 string, arg1 Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish
func (mr *MockMessageBusMockRecorder) Publish(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockMessageBus)(nil).Publish), arg0, arg1)
}

// Subscribe mocks base method
func (m *MockMessageBus) Subscribe(arg0 string) (Subscription, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", arg0)
	ret0, _ := ret[0].(Subscription)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe
func (mr *MockMessageBusMockRecorder) Subscribe(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockMessageBus)(nil).Subscribe), arg0)
}

// MockEventQueue is a mock of EventQueue interface
type MockEventQueue struct {
	ctrl     *gomock.Controller
	recorder *MockEventQueueMockRecorder
}

// MockEventQueueMockRecorder is the mock recorder for MockEventQueue
type MockEventQueueMockRecorder struct {
	mock *MockEventQueue
}

// NewMockEventQueue creates a new mock instance
func NewMockEventQueue(ctrl *gomock.Controller) *MockEventQueue {
	mock := &MockEventQueue{ctrl: ctrl}
	mock.recorder = &MockEventQueueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockEventQueue) EXPECT() *MockEventQueueMockRecorder {
	return m.recorder
}

// Enqueue mocks base method
func (m *MockEventQueue) Enqueue(arg0 string, arg1 Event) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Enqueue", arg0, arg1)
}

// Enqueue indicates an expected call of Enqueue
func (mr *MockEventQueueMockRecorder) Enqueue(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Enqueue", reflect.TypeOf((*MockEventQueue)(nil).Enqueue), arg0, arg1)
}

// Dequeue mocks base method
func (m *MockEventQueue) Dequeue(arg0 string) <-chan Event {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Dequeue", arg0)
	ret0, _ := ret[0].(<-chan Event)
	return ret0
}

// Dequeue indicates an expected call of Dequeue
func (mr *MockEventQueueMockRecorder) Dequeue(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dequeue", reflect.TypeOf((*MockEventQueue)(nil).Dequeue), arg0)
}

// MockLoggable is a mock of Loggable interface
type MockLoggable struct {
	ctrl     *gomock.Controller
	recorder *MockLoggableMockRecorder
}

// MockLoggableMockRecorder is the mock recorder for MockLoggable
type MockLoggableMockRecorder struct {
	mock *MockLoggable
}

// NewMockLoggable creates a new mock instance
func NewMockLoggable(ctrl *gomock.Controller) *MockLoggable {
	mock := &MockLoggable{ctrl: ctrl}
	mock.recorder = &MockLoggableMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockLoggable) EXPECT() *MockLoggableMockRecorder {
	return m.recorder
}

// SetLog mocks base method
func (m *MockLoggable) SetLog(arg0 Log) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetLog", arg0)
}

// SetLog indicates an expected call of SetLog
func (mr *MockLoggableMockRecorder) SetLog(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLog", reflect.TypeOf((*MockLoggable)(nil).SetLog), arg0)
}

// MockMessageAdapter is a mock of MessageAdapter interface
type MockMessageAdapter struct {
	ctrl     *gomock.Controller
	recorder *MockMessageAdapterMockRecorder
}

// MockMessageAdapterMockRecorder is the mock recorder for MockMessageAdapter
type MockMessageAdapterMockRecorder struct {
	mock *MockMessageAdapter
}

// NewMockMessageAdapter creates a new mock instance
func NewMockMessageAdapter(ctrl *gomock.Controller) *MockMessageAdapter {
	mock := &MockMessageAdapter{ctrl: ctrl}
	mock.recorder = &MockMessageAdapterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMessageAdapter) EXPECT() *MockMessageAdapterMockRecorder {
	return m.recorder
}

// Publish mocks base method
func (m *MockMessageAdapter) Publish(arg0 string, arg1 Message) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish
func (mr *MockMessageAdapterMockRecorder) Publish(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockMessageAdapter)(nil).Publish), arg0, arg1)
}

// Subscribe mocks base method
func (m *MockMessageAdapter) Subscribe(arg0 string) (Subscription, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Subscribe", arg0)
	ret0, _ := ret[0].(Subscription)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Subscribe indicates an expected call of Subscribe
func (mr *MockMessageAdapterMockRecorder) Subscribe(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Subscribe", reflect.TypeOf((*MockMessageAdapter)(nil).Subscribe), arg0)
}

// Enqueue mocks base method
func (m *MockMessageAdapter) Enqueue(arg0 string, arg1 Event) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Enqueue", arg0, arg1)
}

// Enqueue indicates an expected call of Enqueue
func (mr *MockMessageAdapterMockRecorder) Enqueue(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Enqueue", reflect.TypeOf((*MockMessageAdapter)(nil).Enqueue), arg0, arg1)
}

// Dequeue mocks base method
func (m *MockMessageAdapter) Dequeue(arg0 string) <-chan Event {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Dequeue", arg0)
	ret0, _ := ret[0].(<-chan Event)
	return ret0
}

// Dequeue indicates an expected call of Dequeue
func (mr *MockMessageAdapterMockRecorder) Dequeue(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Dequeue", reflect.TypeOf((*MockMessageAdapter)(nil).Dequeue), arg0)
}

// SetLog mocks base method
func (m *MockMessageAdapter) SetLog(arg0 Log) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SetLog", arg0)
}

// SetLog indicates an expected call of SetLog
func (mr *MockMessageAdapterMockRecorder) SetLog(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SetLog", reflect.TypeOf((*MockMessageAdapter)(nil).SetLog), arg0)
}
